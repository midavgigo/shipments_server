#include <iostream>
#include <SFML/Graphics.hpp>
#include <cmath>

using namespace std;

const int WORK_WID = 1000;//Рабочая Ширина окна
const int WORK_HEI = 1000;//Рабочая Высота окна
const int WIN_WID = 1200;//Ширина окна
const int WIN_HEI = 1000;//Высота окна
const int SHIFT = WIN_WID-WORK_WID;//Размер сдвига вправо, так как рабочая область находится справа
const double X_MIN = -10;//Минимальное значение абсциссы
const double X_MAX = 10;//Максимальное значение абсциссы
const double Y_MIN = -10;//Минимальное значение ординаты
const double Y_MAX = 10;//Максимальное значение ординаты
const double DX = X_MAX-X_MIN;//Разница между значениями х
const double DY = Y_MAX-Y_MIN;//Разница между значениями у
const double D1 = 0.328079;
const double D2 = -0.343585;
const double A = 0.432;
const double STEP_X = DX/(double)WORK_WID;//Шаг расчетов, при ширине(и высоте) в 1000 пикселей получается значение 0.02, что точно меньше 2 процентов погрешности(я думаю)
const double STEP_Y = DY/(double)WORK_HEI;//Шаг расчетов, при ширине(и высоте) в 1000 пикселей получается значение 0.02, что точно меньше 2 процентов погрешности(я думаю)
sf::Font font;//шрифт для текста 
sf::Text text;//сам текст

void get_from_center(double *coord){//функция преобразования из координат относительно верхнего левого угла, в координаты относительно центра рабочей области в соответствии с декартовой системой координат
    coord[0] -= SHIFT;
    coord[0] = DX/2*(coord[0]-WORK_WID/2)/WORK_WID/2;
    coord[1] = -DY/2*(coord[1]-WORK_HEI/2)/WORK_HEI/2;
}

void get_from_edge(double *coord){//функция, обратная функции выше
    coord[0] = (coord[0]/DX*2)*WORK_WID/2 + WORK_WID/2;
    coord[0] += SHIFT;
    coord[1] = -(coord[1]/DY*2)*WORK_HEI/2 + WORK_HEI/2;
}

double f1(double x, double y){//Первая функция
    return log10(2*x-0.3*y*y) -0.1*x*x+x*y/4 +D1;
}
double f2(double x, double y){//Вторая функция
    return x*x*x+y*y*y-3*A*x*y+D2;
}

double mn1 = 0.009375;//Минимальная погрешность для функции, полученная эксперементальным путём
bool F1(double x, double y){//Возвращает true если значение диапозона находится в отрезке [-mn1; mn1]
    return abs(f1(x, y)) <= mn1;
}
double mn2 = 0.0375;
bool F2(double x, double y){//функция аналогичная
    return abs(f2(x, y)) <= mn2;
}

void draw_line(sf::RenderWindow *win, int x0, int y0, int x1, int y1){//Рисует линию по 2 точкам
        sf::Vertex line[] = {sf::Vertex(sf::Vector2f(x0, y0)), sf::Vertex(sf::Vector2f(x1, y1))};//массив с 2 точками
        win->draw(line, 2, sf::Lines);
}

void draw_steps(sf::RenderWindow *win, int x, int y){//Рисует отметки на осях
    double x0, y0;
    double x1, y1;
    (x!=0 ? (x0 = -10, y0 = .15, x1 = -10, y1=-.1): (x0 = -.15, y0 = -10, x1 = .15, y1 = -10));//В зависимости от шага, который передается в аргументах, изменяем начальные координаты точек линии
    text.setFillColor(sf::Color::White);//Исползуем белый шрифт
    text.setString("0");//Начало координат
    text.setPosition(sf::Vector2f(WORK_WID/2 + SHIFT -15, WIN_HEI/2 -25));//Позиция текста
    win->draw(text);//Отрисовываем
    while((x0 >= X_MIN && x0 < X_MAX) && (y0 >= Y_MIN && y0 < Y_MAX)){//Если отметки не вышли за предел диапозона x и y
        (x!=0 ? text.setString(to_string((int)x0)): text.setString(to_string((int)y0)));//Устанавливаем значение текста, также исходя из шага
        double coord[4] = {x0, y0, x1, y1};
        get_from_edge(&coord[0]);
        get_from_edge(&coord[2]);//Преобразуем координаты
        draw_line(win, (int)coord[0], (int)coord[1], (int)coord[2], (int)coord[3]);
        int sx =0, sy = 0;//Сдвиги текста значений отметок
        (x!=0 ? (sx = -5, sy= -15) : (sx = -15, sy = -15));
        text.setPosition(sf::Vector2f((int)coord[0]+sx, (int)coord[1]+sy));
        if(x0!=0 && y0!=0){//Начало координат мы уже отрисовали
            win->draw(text);
        }
        x0 += x;
        x1 += x;
        y0 += y;
        y1 += y;
    }
}

void draw_back(sf::RenderWindow *window){//Отрисовка обозначений
        draw_line(window, SHIFT, WORK_HEI/2, WORK_WID+SHIFT, WORK_HEI/2);//ось OX
        draw_line(window, WORK_WID/2+SHIFT, 0, WORK_WID/2+SHIFT, WORK_HEI);//ось OY
        draw_steps(window, 1, 0);//отметки на ОХ
        draw_steps(window, 0, 1);//отметки на ОУ

        text.setFillColor(sf::Color::Red);
        text.setString("F1 = lg(2*x-0.3*y^2)-0.1*x^2+x*y/4 +D1");
        text.setPosition(sf::Vector2f(0, 0));
        window->draw(text);
        text.setFillColor(sf::Color::Green);
        text.setString("F2 = x^3+y^3-3*A*x*y+D2");
        text.setPosition(sf::Vector2f(0, 20));
        window->draw(text);

        sf::CircleShape arrow(10, 3);//Отрисовка стрелочек
        arrow.setPosition(sf::Vector2f(WORK_WID/2+SHIFT-10, 0));
        arrow.setFillColor(sf::Color::White);
        window->draw(arrow);
        arrow.setPosition(sf::Vector2f(WIN_WID, WIN_HEI/2-10));
        arrow.setRotation(90);
        window->draw(arrow);
}

int main(){
    font.loadFromFile("arial.ttf");//Загружаем шрифт
    text.setFont(font);//Устанавливаем шрифт
    text.setCharacterSize(15);//Устанавливаем значение размера текста в пикселях
    sf::RenderWindow window(sf::VideoMode(WIN_WID, WIN_HEI), "My window");//Создаем окно
    while(window.isOpen()){//Пока окно окрыто
        sf::Event event;
        while (window.pollEvent(event)){//Проходимся по событиям на окне
            if (event.type == sf::Event::Closed){//Если событие закрытие окна
                window.close();//Закрываем окно
            }
        }
        window.clear(sf::Color::Black);//Очищаем окно черным цветом

        sf::VertexArray pmap(sf::Points, WORK_WID*WORK_HEI);//Массив с точками
        for(int y = 0; y < WORK_HEI; y++){
            for(int x = SHIFT; x < WORK_WID+SHIFT; x++){//Проходимся по всем точкам рабочей области
                double coord[2] = {x, y};
                get_from_center(coord);
                if(F1(coord[0], coord[1])){
                    pmap[y*WORK_WID + x-SHIFT].position = sf::Vector2f(x, y);//Устанавливаем позицию точки 
                    pmap[y*WORK_WID + x-SHIFT].color = sf::Color::Red;//Устанавливаем цвет
                }
                if(F2(coord[0], coord[1])){
                    pmap[y*WORK_WID + x-SHIFT].position = sf::Vector2f(x, y);
                    pmap[y*WORK_WID + x-SHIFT].color = sf::Color::Green;
                }
            }
        }
        window.draw(pmap);//Рисуем массив точек
        draw_back(&window);//Рисуем обозначения
        window.display();//Отображаем на экране
    }
    return 0;
}
